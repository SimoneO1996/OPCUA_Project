"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable: no-console
/**
 * @module node-opcua-client-dynamic-extension-object
 */
const chalk = require("chalk");
const _ = require("underscore");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_schemas_1 = require("node-opcua-schemas");
const node_opcua_service_browse_1 = require("node-opcua-service-browse");
const node_opcua_service_translate_browse_path_1 = require("node-opcua-service-translate-browse-path");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_types_1 = require("node-opcua-types");
const doDebug = node_opcua_debug_1.checkDebugFlag(__filename);
const debugLog = node_opcua_debug_1.make_debugLog(__filename);
function _readDeprecatedFlag(session, dataTypeDictionary) {
    return __awaiter(this, void 0, void 0, function* () {
        const browsePath = node_opcua_service_translate_browse_path_1.makeBrowsePath(dataTypeDictionary, ".Deprecated");
        const a = yield session.translateBrowsePath(browsePath);
        /* istanbul ignore next */
        if (!a.targets || a.targets.length === 0) {
            debugLog("Cannot find Deprecated property for dataTypeDictionary " + dataTypeDictionary.toString());
            return false;
        }
        const deprecatedFlagNodeId = a.targets[0].targetId;
        const dataValue = yield session.read({ nodeId: deprecatedFlagNodeId, attributeId: node_opcua_data_model_1.AttributeIds.Value });
        return dataValue.value.value;
    });
}
function _readNamespaceUriProperty(session, dataTypeDictionary) {
    return __awaiter(this, void 0, void 0, function* () {
        const a = yield session.translateBrowsePath(node_opcua_service_translate_browse_path_1.makeBrowsePath(dataTypeDictionary, ".NamespaceUri"));
        /* istanbul ignore next */
        if (!a.targets || a.targets.length === 0) {
            return "??dataTypeDictionary doesn't expose NamespaceUri property??";
        }
        const namespaceUriProp = a.targets[0].targetId;
        const dataValue = yield session.read({ nodeId: namespaceUriProp, attributeId: node_opcua_data_model_1.AttributeIds.Value });
        return dataValue.value.value || "<not set>";
    });
}
function _getDataTypeDescriptions(session, dataTypeDictionaryNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeToBrowse2 = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Forward,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Variable"),
            nodeId: dataTypeDictionaryNodeId,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasComponent"),
            // resultMask: makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass | TypeDefinition")
            resultMask: node_opcua_data_model_1.makeResultMask("NodeId | BrowseName")
        };
        const result2 = yield session.browse(nodeToBrowse2);
        result2.references = result2.references || [];
        return result2.references.map((r) => ({ nodeId: r.nodeId, browseName: r.browseName }));
    });
}
function _enrichWithDescriptionOf(session, dataTypeDescriptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodesToBrowse3 = [];
        for (const ref of dataTypeDescriptions) {
            ref.browseName.toString();
            nodesToBrowse3.push({
                browseDirection: node_opcua_service_browse_1.BrowseDirection.Inverse,
                includeSubtypes: false,
                nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Object"),
                nodeId: ref.nodeId.toString(),
                referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasDescription"),
                //            resultMask: makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass | TypeDefinition")
                resultMask: node_opcua_data_model_1.makeResultMask("NodeId")
            });
        }
        const results3 = yield session.browse(nodesToBrowse3);
        const binaryEncodings = [];
        const nodesToBrowseDataType = [];
        let i = 0;
        for (const result3 of results3) {
            const dataTypeDescription = dataTypeDescriptions[i++];
            result3.references = result3.references || [];
            node_opcua_assert_1.assert(result3.references.length === 1);
            for (const ref of result3.references) {
                const binaryEncodingNodeId = ref.nodeId;
                dataTypeDescription.encodings = dataTypeDescription.encodings || {
                    binaryEncodingNodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
                    dataTypeNodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
                    jsonEncodingNodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
                    xmlEncodingNodeId: node_opcua_nodeid_1.NodeId.nullNodeId
                };
                dataTypeDescription.encodings.binaryEncodingNodeId = binaryEncodingNodeId;
                binaryEncodings.push(binaryEncodingNodeId);
                nodesToBrowseDataType.push({
                    browseDirection: node_opcua_service_browse_1.BrowseDirection.Inverse,
                    includeSubtypes: false,
                    nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("DataType"),
                    nodeId: ref.nodeId.toString(),
                    referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasEncoding"),
                    //            resultMask: makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass | TypeDefinition")
                    resultMask: node_opcua_data_model_1.makeResultMask("NodeId | BrowseName")
                });
            }
        }
        const results4 = yield session.browse(nodesToBrowseDataType);
        const dataTypeNodeIds = [];
        i = 0;
        for (const result4 of results4) {
            result4.references = result4.references || [];
            /* istanbul ignore next */
            if (result4.references.length !== 1) {
                console.log("What's going on ?", result4.toString());
            }
            for (const ref of result4.references) {
                const dataTypeNodeId = ref.nodeId;
                dataTypeNodeIds.push(dataTypeNodeId);
                const dataTypeDescription = dataTypeDescriptions[i++];
                dataTypeDescription.encodings.dataTypeNodeId = dataTypeNodeId;
            }
        }
        return dataTypeNodeIds;
    });
}
function _findEncodings(session, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeToBrowse = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Forward,
            includeSubtypes: true,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Object"),
            nodeId: dataTypeNodeId,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasEncoding"),
            resultMask: node_opcua_data_model_1.makeResultMask("ReferenceType | IsForward | BrowseName | NodeClass | TypeDefinition")
        };
        const result = yield session.browse(nodeToBrowse);
        const references = result.references || [];
        if (references.length === 0) {
            throw new Error("Cannot find encodings on type " + dataTypeNodeId.toString() + " statusCode " + result.statusCode.toString());
        }
        const encodings = {
            dataTypeNodeId,
            binaryEncodingNodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
            jsonEncodingNodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
            xmlEncodingNodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
        };
        for (const ref of references) {
            switch (ref.browseName.name) {
                case "Default Binary":
                    encodings.binaryEncodingNodeId = ref.nodeId;
                    break;
                case "Default XML":
                    encodings.xmlEncodingNodeId = ref.nodeId;
                    break;
                case "Default JSON":
                    encodings.jsonEncodingNodeId = ref.nodeId;
                    break;
                default:
                    console.log(" ignoring encoding ", ref.browseName.toString());
            }
        }
        return encodings;
    });
}
function sortStructure(dataTypeDefinitions) {
    const dataTypeDefinitionsSorted = [];
    const _visited = {};
    const _map = {};
    for (const d of dataTypeDefinitions) {
        _map[d.dataTypeNodeId.toString()] = d;
    }
    function _visit(d) {
        const hash = d.dataTypeNodeId.toString();
        if (_visited[hash]) {
            return;
        }
        const bbb = _map[d.dataTypeDefinition.baseDataType.toString()];
        if (bbb) {
            _visit(bbb);
        }
        for (const f of d.dataTypeDefinition.fields || []) {
            const ddd = _map[f.dataType.toString()];
            if (!ddd) {
                continue;
            }
            _visit(ddd);
        }
        _visited[hash] = d;
        dataTypeDefinitionsSorted.push(d);
    }
    for (const d of dataTypeDefinitions) {
        _visit(d);
    }
    return dataTypeDefinitionsSorted;
}
function _extractDataTypeDictionaryFromDefinition(session, dataTypeDictionaryNodeId, dataTypeFactory) {
    return __awaiter(this, void 0, void 0, function* () {
        node_opcua_assert_1.assert(dataTypeFactory, "expecting a dataTypeFactory");
        const dataTypeDescriptions = yield _getDataTypeDescriptions(session, dataTypeDictionaryNodeId);
        const dataTypeNodeIds = yield _enrichWithDescriptionOf(session, dataTypeDescriptions);
        // now read DataTypeDefition attributes of all the dataTypeNodeIds, this will only contains concrete structure
        const nodesToRead = dataTypeNodeIds.map((nodeId) => ({
            attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition, nodeId,
        }));
        const cache = {};
        const dataValuesWithDataTypeDefinition = yield session.read(nodesToRead);
        node_opcua_assert_1.assert(dataValuesWithDataTypeDefinition.length === dataTypeDescriptions.length);
        const dataTypeDefinitions = [];
        let index = 0;
        for (const dataValue of dataValuesWithDataTypeDefinition) {
            const dataTypeNodeId = dataTypeNodeIds[index];
            const dataTypeDescription = dataTypeDescriptions[index];
            /* istanbul ignore else */
            if (dataValue.statusCode === node_opcua_status_code_1.StatusCodes.Good) {
                const dataTypeDefinition = dataValue.value.value;
                if (dataTypeDefinition && dataTypeDefinition instanceof node_opcua_types_1.StructureDefinition) {
                    const className = dataTypeDescription.browseName.name;
                    dataTypeDefinitions.push({ className, dataTypeNodeId, dataTypeDefinition });
                }
            }
            else {
                debugLog("dataTypeNodeId ", dataTypeNodeId.toString(), " has no DataTypeDescription attribute", dataValue.statusCode.toString());
            }
            index++;
        }
        // to do put in logicial order
        const dataTypeDefinitionsSorted = sortStructure(dataTypeDefinitions);
        if (doDebug) {
            debugLog("order ", dataTypeDefinitionsSorted.map((a) => a.className + " " + a.dataTypeNodeId).join(" ->  "));
        }
        for (const { className, dataTypeNodeId, dataTypeDefinition } of dataTypeDefinitionsSorted) {
            // istanbul ignore next
            if (doDebug) {
                console.log(chalk.yellow("--------------------------------------- "), className, dataTypeNodeId.toString());
            }
            if (dataTypeFactory.hasStructuredType(className)) {
                continue; // this structure has already been seen
            }
            // now fill typeDictionary
            try {
                const schema = yield convertDataTypeDefinitionToStructureTypeSchema(session, dataTypeNodeId, className, dataTypeDefinition, dataTypeFactory, cache);
                // istanbul ignore next
                if (doDebug) {
                    debugLog(chalk.red("Registering "), chalk.cyan(className.padEnd(30, " ")), schema.dataTypeNodeId.toString());
                }
                const Constructor = node_opcua_schemas_1.createDynamicObjectConstructor(schema, dataTypeFactory);
                node_opcua_assert_1.assert(Constructor.schema === schema);
            }
            catch (err) {
                console.log("Constructor verification err: ", err.message);
                console.log("For this reason class " + className + " has not been registered");
                console.log(err);
            }
        }
    });
}
function _extractNodeIds(session, dataTypeDictionaryNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const map = {};
        const dataTypeDescriptions = yield _getDataTypeDescriptions(session, dataTypeDictionaryNodeId);
        /* const dataTypeNodeIds =  */
        yield _enrichWithDescriptionOf(session, dataTypeDescriptions);
        for (const dataTypeDescription of dataTypeDescriptions) {
            map[dataTypeDescription.browseName.name.toString()] = dataTypeDescription.encodings;
        }
        return {
            getDataTypeAndEncodingId(key) {
                return map[key];
            }
        };
    });
}
function _extractDataTypeDictionary(session, dataTypeDictionaryNodeId, dataTypeManager) {
    return __awaiter(this, void 0, void 0, function* () {
        const isDictionaryDeprecated = yield _readDeprecatedFlag(session, dataTypeDictionaryNodeId);
        const rawSchemaDataValue = yield session.read({ nodeId: dataTypeDictionaryNodeId, attributeId: node_opcua_data_model_1.AttributeIds.Value });
        const name = yield session.read({ nodeId: dataTypeDictionaryNodeId, attributeId: node_opcua_data_model_1.AttributeIds.BrowseName });
        const namespace = yield _readNamespaceUriProperty(session, dataTypeDictionaryNodeId);
        if (isDictionaryDeprecated || !rawSchemaDataValue.value.value) {
            debugLog("DataTypeDictionary is deprecated or BSD schema stored in dataValue is null !", chalk.cyan(name.value.value.toString()), "namespace =", namespace);
            debugLog("lets use the new way (1.04) and let's crawl all dataTypes exposed by this name space");
            // dataType definition in store directily in UADataType under the $definition property
            const dataTypeFactory2 = dataTypeManager.getDataTypeFactory(dataTypeDictionaryNodeId.namespace);
            if (!dataTypeFactory2) {
                throw new Error("cannot find dataTypeFactort for namespace " + dataTypeDictionaryNodeId.namespace);
            }
            yield _extractDataTypeDictionaryFromDefinition(session, dataTypeDictionaryNodeId, dataTypeFactory2);
            return;
        }
        else {
            debugLog(" ----- Using old method for extracting schema => with BSD files");
            // old method ( until 1.03 )
            // one need to read the schema file store in the dataTypeDictionary node and parse it !
            const rawSchema = rawSchemaDataValue.value.value.toString();
            /* istanbul ignore next */
            if (doDebug) {
                debugLog("---------------------------------------------");
                debugLog(rawSchema.toString());
                debugLog("---------------------------------------------");
            }
            const idProvider = yield _extractNodeIds(session, dataTypeDictionaryNodeId);
            const dataTypeFactory1 = dataTypeManager.getDataTypeFactory(dataTypeDictionaryNodeId.namespace);
            yield node_opcua_schemas_1.parseBinaryXSDAsync(rawSchema, idProvider, dataTypeFactory1);
        }
    });
}
function _exploreDataTypeDefinition(session, dataTypeDictionaryTypeNode, dataTypeFactory, namespaces) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeToBrowse = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Forward,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Variable"),
            nodeId: dataTypeDictionaryTypeNode,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasComponent"),
            resultMask: node_opcua_data_model_1.makeResultMask("ReferenceType | IsForward | BrowseName | NodeClass | TypeDefinition")
        };
        const result = yield session.browse(nodeToBrowse);
        const references = result.references || [];
        /* istanbul ignore next */
        if (references.length === 0) {
            return;
        }
        // request the Definition of each nodes
        const nodesToBrowse2 = references.map((ref) => {
            return {
                browseDirection: node_opcua_service_browse_1.BrowseDirection.Inverse,
                includeSubtypes: false,
                nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Object | Variable"),
                nodeId: ref.nodeId,
                referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasDescription"),
                resultMask: node_opcua_data_model_1.makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass | TypeDefinition")
            };
        });
        const results2 = yield session.browse(nodesToBrowse2);
        const binaryEncodingNodeIds = results2.map((br) => {
            const defaultBin = br.references.filter((r) => r.browseName.toString() === "Default Binary");
            /* istanbul ignore next */
            if (defaultBin.length < 1) {
                return node_opcua_nodeid_1.ExpandedNodeId;
            }
            return node_opcua_nodeid_1.ExpandedNodeId.fromNodeId(defaultBin[0].nodeId, namespaces[defaultBin[0].nodeId.namespace]);
        });
        // follow now Default Binary <= [Has Encoding] = [DataType]
        /* istanbul ignore next */
        if (doDebug) {
            console.log(chalk.bgWhite.red("testing new constructors"));
            const tuples = _.zip(references, binaryEncodingNodeIds);
            for (const [ref, binaryEncoding] of tuples) {
                const name = ref.browseName.name.toString();
                if (doDebug) {
                    debugLog("      type ", name.padEnd(30, " "), binaryEncoding.toString());
                }
                // let's verify that constructor is operational
                try {
                    const constructor = dataTypeFactory.getStructureTypeConstructor(name);
                    // xx const constructor = getOrCreateConstructor(name, dataTypeFactory, defaultBinary);
                    const testObject = new constructor();
                    debugLog(testObject.toString());
                }
                catch (err) {
                    debugLog("         Error cannot construct Extension Object " + name);
                    debugLog("         " + err.message);
                }
            }
        }
    });
}
/**
 * Extract all custom dataType
 * @param session
 * @param dataTypeManager
 * @async
 */
function populateDataTypeManager(session, dataTypeManager) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        debugLog("in ... populateDataTypeManager");
        // read namespace array
        const dataValueNamespaceArray = yield session.read({
            attributeId: node_opcua_data_model_1.AttributeIds.Value,
            nodeId: node_opcua_nodeid_1.resolveNodeId("Server_NamespaceArray")
        });
        const namespaceArray = dataValueNamespaceArray.value.value;
        if (dataValueNamespaceArray.statusCode === node_opcua_status_code_1.StatusCodes.Good &&
            (namespaceArray && namespaceArray.length > 0)) {
            dataTypeManager.setNamespaceArray(namespaceArray);
            for (let namespaceIndex = 1; namespaceIndex < namespaceArray.length; namespaceIndex++) {
                if (!dataTypeManager.hasDataTypeFactory(namespaceIndex)) {
                    const dataTypeFactory1 = new node_opcua_factory_1.DataTypeFactory([node_opcua_factory_1.getStandartDataTypeFactory()]);
                    dataTypeManager.registerDataTypeFactory(namespaceIndex, dataTypeFactory1);
                }
            }
        }
        /// to do :: may be not useful
        if (!dataValueNamespaceArray.value.value && dataTypeManager.namespaceArray.length === 0) {
            dataTypeManager.setNamespaceArray([]);
        }
        const dataTypeDictionaryType = node_opcua_nodeid_1.resolveNodeId("DataTypeDictionaryType");
        // DataType/OPCBinary => i=93 [OPCBinarySchema_TypeSystem]
        // "OPC Binary"[DataSystemType]
        const opcBinaryNodeId = node_opcua_nodeid_1.resolveNodeId("OPCBinarySchema_TypeSystem");
        debugLog(opcBinaryNodeId.toString());
        // let find all DataType dictionary node corresponding to a given namespace
        // (have DataTypeDictionaryType)
        const nodeToBrowse = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Forward,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Variable"),
            nodeId: opcBinaryNodeId,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasComponent"),
            resultMask: node_opcua_data_model_1.makeResultMask("ReferenceType | IsForward | BrowseName | NodeClass | TypeDefinition")
        };
        const result = yield session.browse(nodeToBrowse);
        if (doDebug) {
            debugLog(result.statusCode.toString());
            debugLog((_a = result.references) === null || _a === void 0 ? void 0 : _a.map((r) => { var _a; return (_a = r.browseName) === null || _a === void 0 ? void 0 : _a.toString(); }).join(" "));
        }
        // filter nodes that have the expected namespace Index
        // ( more specifically we want to filter out DataStructure from namespace 0)
        // we also want to keep only object of type DataTypeDictionaryType
        const references = result.references.filter((e) => e.nodeId.namespace !== 0 &&
            node_opcua_nodeid_1.sameNodeId(e.typeDefinition, dataTypeDictionaryType));
        debugLog(`found ${references.length} dictionnary`);
        // now investigate DataTypeDescriptionType
        yield (() => __awaiter(this, void 0, void 0, function* () {
            function processReference2(ref) {
                return __awaiter(this, void 0, void 0, function* () {
                    const dataTypeDicitionaryNodeId = ref.nodeId;
                    // xx const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(dataTypeDicitionaryNodeId.namespace);
                    yield _extractDataTypeDictionary(session, dataTypeDicitionaryNodeId, dataTypeManager);
                    /* istanbul ignore next */
                    if (doDebug) {
                        debugLog(chalk.bgWhite("                                         => "), ref.browseName.toString(), ref.nodeId.toString());
                    }
                    const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(dataTypeDicitionaryNodeId.namespace);
                    yield _exploreDataTypeDefinition(session, dataTypeDicitionaryNodeId, dataTypeFactory, dataTypeManager.namespaceArray);
                });
            }
            const promises2 = [];
            for (const ref of references) {
                promises2.push(processReference2(ref));
            }
            yield Promise.all(promises2);
        }))();
        debugLog("out ... populateDataTypeManager");
    });
}
exports.populateDataTypeManager = populateDataTypeManager;
function getHasEncodingDefaultBinary(session, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeToBrowse1 = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Forward,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Object"),
            nodeId: dataTypeNodeId,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasEncoding"),
            resultMask: node_opcua_data_model_1.makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass | TypeDefinition")
        };
        const result1 = yield session.browse(nodeToBrowse1);
        if (result1.references && result1.references.length > 1) {
            // we have more than one possible Encoding .... only keep "Default Binary"
            result1.references = result1.references.filter((r) => r.browseName.toString() === "Default Binary");
        }
        /* istanbul ignore next */
        if (!(result1.references && result1.references.length === 1)) {
            // may be dataTypeNodeId is not a dataType,
            // let's verify this.
            const nodeClass = yield session.read({
                attributeId: node_opcua_data_model_1.AttributeIds.NodeClass,
                nodeId: dataTypeNodeId
            });
            const browseName = yield session.read({
                attributeId: node_opcua_data_model_1.AttributeIds.BrowseName,
                nodeId: dataTypeNodeId
            });
            // tslint:disable:no-console
            console.log("node-id    :", dataTypeNodeId ? dataTypeNodeId.toString() : null);
            console.log("nodeClass  :", node_opcua_data_model_1.NodeClass[nodeClass.value.value]);
            console.log("browseName :", browseName.toString());
            console.log(result1.toString());
            throw new Error("getDataTypeDefinition invalid HasEncoding reference dataTypeNodeId must be NodeClass.DataType but was " + node_opcua_data_model_1.NodeClass[nodeClass.value.value]);
        }
        const encodingReference = result1.references[0];
        node_opcua_assert_1.assert(encodingReference.browseName.toString() === "Default Binary");
        /* istanbul ignore next */
        if (doDebug) {
            const browseName = yield session.read({
                attributeId: node_opcua_data_model_1.AttributeIds.BrowseName,
                nodeId: dataTypeNodeId
            });
            debugLog(browseName.value.value.toString(), "Has Encoding ", encodingReference.browseName.toString(), encodingReference.nodeId.toString());
        }
        return encodingReference.nodeId;
    });
}
function getDefinition(session, defaultBinaryEncodingNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeToBrowse2 = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Forward,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Variable"),
            nodeId: defaultBinaryEncodingNodeId,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasDescription"),
            resultMask: node_opcua_data_model_1.makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass | TypeDefinition")
        };
        const result2 = yield session.browse(nodeToBrowse2);
        node_opcua_assert_1.assert(result2.references && result2.references.length === 1);
        const definitionRef = result2.references[0];
        const nameDataValue = yield session.read({
            attributeId: node_opcua_data_model_1.AttributeIds.Value,
            nodeId: definitionRef.nodeId
        });
        if (nameDataValue.statusCode !== node_opcua_status_code_1.StatusCodes.Good) {
            throw new Error("Cannot find ...  " + definitionRef.nodeId.toString());
        }
        /*
        const name = nameDataValue.value.value as string;
        if (!name) {
            console.log(nameDataValue.toString());
            throw new Error("Cannot find ...  " + name + " " + definitionRef.nodeId.toString());
        }
        */
        return definitionRef.nodeId;
    });
}
function getSchemaNode(session, definitionRefNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        // find parent node to access the xsd File
        const nodeToBrowse3 = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Inverse,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("Variable"),
            nodeId: definitionRefNodeId,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasComponent"),
            resultMask: node_opcua_data_model_1.makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass | TypeDefinition")
        };
        const result3 = yield session.browse(nodeToBrowse3);
        node_opcua_assert_1.assert(result3.references && result3.references.length === 1);
        const schemaNode = result3.references[0].nodeId;
        return schemaNode;
    });
}
function getDataTypeDefinition(session, dataTypeNodeId, 
// tslint:disable-next-line: no-shadowed-variable
dataTypeManager) {
    return __awaiter(this, void 0, void 0, function* () {
        // DataType
        //    | 1
        //    | n
        //    +- HasEncoding-> "Default Binary" (O)[DataTypeEncodingType]
        //                           |
        //                           +-- HasDescription -> "MyItemType" (V)[DataTypeDescriptionType]
        //                                                    |
        //                                                    +- ComponentOf -> Schema(V) []
        //                                                                         |
        //                                                                         +- ComponentOf -> OPC Binary(V)[DataTypeSystemType]
        //
        // Note that in 1.04 compliant server, DataType definition might be available
        //           in a DataTypeDefinition attributes of the DataType object
        //           However this is a brand new aspect of the specification and is not widely implemented
        //           it is also optional
        //           It will takes time for old opcua server to be refurbished and we may have to
        //           keep the current method to access type definition from embedded xsd.
        //
        const defaultBinaryEncodingNodeId = yield getHasEncodingDefaultBinary(session, dataTypeNodeId);
        const definitionRefNodeId = yield getDefinition(session, defaultBinaryEncodingNodeId);
        const schemaNode = yield getSchemaNode(session, definitionRefNodeId);
        const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(schemaNode.namespace);
        /* istanbul ignore next */
        if (!dataTypeFactory) {
            throw new Error(" cannot find typeDictionary for  " + schemaNode.toString());
        }
        const name = yield (yield session.read({ nodeId: dataTypeNodeId, attributeId: node_opcua_data_model_1.AttributeIds.BrowseName })).value.value.name;
        const schema = dataTypeFactory.getStructuredTypeSchema(name);
        return schema;
    });
}
exports.getDataTypeDefinition = getDataTypeDefinition;
function findSuperType(session, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const nodeToBrowse3 = {
            browseDirection: node_opcua_service_browse_1.BrowseDirection.Inverse,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.makeNodeClassMask("DataType"),
            nodeId: dataTypeNodeId,
            referenceTypeId: node_opcua_nodeid_1.resolveNodeId("HasSubtype"),
            resultMask: node_opcua_data_model_1.makeResultMask("NodeId | ReferenceType | BrowseName | NodeClass")
        };
        const result3 = yield session.browse(nodeToBrowse3);
        /* istanbul ignore next */
        if (result3.statusCode !== node_opcua_status_code_1.StatusCodes.Good) {
            throw new Error("Cannot find superType for " + dataTypeNodeId.toString());
        }
        result3.references = result3.references || [];
        /* istanbul ignore next */
        if (result3.references.length !== 1) {
            console.log(result3.toString());
            throw new Error("Invalid dataType with more than one superType " + dataTypeNodeId.toString());
        }
        return result3.references[0].nodeId;
    });
}
function findDataTypeCategory(session, cache, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const subTypeNodeId = yield findSuperType(session, dataTypeNodeId);
        debugLog("subTypeNodeId  of ", dataTypeNodeId.toString(), " is ", subTypeNodeId.toString());
        const key = subTypeNodeId.toString();
        if (cache[key]) {
            return cache[key].category;
        }
        let category;
        if (subTypeNodeId.namespace === 0 && subTypeNodeId.value < 29) {
            // well knwow node ID !
            switch (subTypeNodeId.value) {
                case 22: /* Structure */
                    category = node_opcua_factory_1.FieldCategory.complex;
                    break;
                case 29: /* Enumeration */
                    category = node_opcua_factory_1.FieldCategory.enumeration;
                    break;
                default:
                    category = node_opcua_factory_1.FieldCategory.basic;
                    break;
            }
            return category;
        }
        // must drill down ...
        return yield findDataTypeCategory(session, cache, subTypeNodeId);
    });
}
function findDataTypeBasicType(session, cache, dataTypeNodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const subTypeNodeId = yield findSuperType(session, dataTypeNodeId);
        debugLog("subTypeNodeId  of ", dataTypeNodeId.toString(), " is ", subTypeNodeId.toString());
        const key = subTypeNodeId.toString();
        if (cache[key]) {
            return cache[key].schema;
        }
        if (subTypeNodeId.namespace === 0 && subTypeNodeId.value < 29) {
            switch (subTypeNodeId.value) {
                case 22: /* Structure */
                case 29: /* Enumeration */
                    throw new Error("Not expecting Structure or Enumeration");
                default:
                    break;
            }
            const nameDataValue = yield session.read({ nodeId: subTypeNodeId, attributeId: node_opcua_data_model_1.AttributeIds.BrowseName });
            const name = nameDataValue.value.value.name;
            return node_opcua_factory_1.getBuildInType(name);
        }
        // must drill down ...
        return yield findDataTypeBasicType(session, cache, subTypeNodeId);
    });
}
function readBrowseName(session, nodeId) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataValue = yield session.read({ nodeId, attributeId: node_opcua_data_model_1.AttributeIds.BrowseName });
        if (dataValue.statusCode !== node_opcua_status_code_1.StatusCodes.Good) {
            const message = "cannot extract BrowseName of nodeId = " + nodeId.toString();
            debugLog(message);
            throw new Error(message);
        }
        return dataValue.value.value.name;
    });
}
function resolveFieldType(session, dataTypeNodeId, dataTypeFactory, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        if (dataTypeNodeId.value === 0 || (dataTypeNodeId.namespace === 0 && dataTypeNodeId.value === 22)) {
            // this is the default Structure !
            // throw new Error("invalid nodeId " + dataTypeNodeId.toString());
            return null;
        }
        const key = dataTypeNodeId.toString();
        const v = cache[key];
        if (v) {
            return v;
        }
        const fieldTypeName = yield readBrowseName(session, dataTypeNodeId);
        let schema;
        let category = node_opcua_factory_1.FieldCategory.enumeration;
        if (dataTypeFactory.hasStructuredType(fieldTypeName)) {
            schema = dataTypeFactory.getStructuredTypeSchema(fieldTypeName);
            category = node_opcua_factory_1.FieldCategory.complex;
        }
        else if (dataTypeFactory.hasSimpleType(fieldTypeName)) {
            category = node_opcua_factory_1.FieldCategory.basic;
            schema = dataTypeFactory.getSimpleType(fieldTypeName);
        }
        else if (dataTypeFactory.hasEnumeration(fieldTypeName)) {
            category = node_opcua_factory_1.FieldCategory.enumeration;
            schema = dataTypeFactory.getEnumeration(fieldTypeName);
        }
        else {
            debugLog(" type " + fieldTypeName + " has not been seen yet, let resolve it");
            category = yield findDataTypeCategory(session, cache, dataTypeNodeId);
            debugLog(" type " + fieldTypeName + " has not been seen yet, let resolve it => (category = ", category, " )");
            switch (category) {
                case "basic":
                    schema = yield findDataTypeBasicType(session, cache, dataTypeNodeId);
                    break;
                default:
                case "complex":
                case "enumeration":
                    const dataTypeDefinitionDataValue = yield session.read({
                        attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition,
                        nodeId: dataTypeNodeId,
                    });
                    /* istanbul ignore next */
                    if (dataTypeDefinitionDataValue.statusCode !== node_opcua_status_code_1.StatusCodes.Good) {
                        throw new Error(" Cannot find dataType Definition ! with nodeId =" + dataTypeNodeId.toString());
                    }
                    const definition = dataTypeDefinitionDataValue.value.value;
                    schema = yield convertDataTypeDefinitionToStructureTypeSchema(session, dataTypeNodeId, fieldTypeName, definition, dataTypeFactory, cache);
                    // xx const schema1 = dataTypeFactory.getStructuredTypeSchema(fieldTypeName);
                    break;
            }
        }
        node_opcua_assert_1.assert(schema, "expecting a schema here");
        const v2 = {
            category,
            fieldTypeName,
            schema
        };
        cache[key] = v2;
        return v2;
    });
}
function _setupEncodings(session, dataTypeNodeId, schema) {
    return __awaiter(this, void 0, void 0, function* () {
        // read abstract flag
        const isAbstractDV = yield session.read({ nodeId: dataTypeNodeId, attributeId: node_opcua_data_model_1.AttributeIds.IsAbstract });
        schema.dataTypeNodeId = dataTypeNodeId;
        schema.id = dataTypeNodeId;
        if (isAbstractDV.statusCode === node_opcua_status_code_1.StatusCodes.Good && isAbstractDV.value.value === false) {
            const encodings = yield _findEncodings(session, dataTypeNodeId);
            schema.encodingDefaultBinary = node_opcua_nodeid_1.makeExpandedNodeId(encodings.binaryEncodingNodeId);
            schema.encodingDefaultXml = node_opcua_nodeid_1.makeExpandedNodeId(encodings.xmlEncodingNodeId);
            schema.encodingDefaultJson = node_opcua_nodeid_1.makeExpandedNodeId(encodings.jsonEncodingNodeId);
        }
        return schema;
    });
}
function convertDataTypeDefinitionToStructureTypeSchema(session, dataTypeNodeId, name, definition, dataTypeFactory, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        if (definition instanceof node_opcua_types_1.StructureDefinition) {
            switch (definition.structureType) {
                case node_opcua_types_1.StructureType.Structure:
                case node_opcua_types_1.StructureType.StructureWithOptionalFields:
                    break;
            }
            const fields = [];
            for (const fieldD of definition.fields) {
                const { schema, category, fieldTypeName } = (yield resolveFieldType(session, fieldD.dataType, dataTypeFactory, cache));
                const field = {
                    fieldType: fieldTypeName,
                    name: fieldD.name,
                    schema,
                };
                if (fieldD.valueRank === 1) {
                    field.isArray = true;
                }
                field.category = category;
                fields.push(field);
            }
            const a = yield resolveFieldType(session, definition.baseDataType, dataTypeFactory, cache);
            const baseType = a ? a.fieldTypeName : "ExtensionObject";
            const os = new node_opcua_factory_1.StructuredTypeSchema({
                baseType,
                fields,
                id: 0,
                name,
            });
            return yield _setupEncodings(session, dataTypeNodeId, os);
        }
        throw new Error("Not Implemented");
    });
}
exports.convertDataTypeDefinitionToStructureTypeSchema = convertDataTypeDefinitionToStructureTypeSchema;
//# sourceMappingURL=client_dynamic_extension_object.js.map